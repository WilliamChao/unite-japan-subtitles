1
00:00:26,029 --> 00:00:29,710
Hello, my name is
Kim Steen Riber.

2
00:00:29,710 --> 00:00:32,620
I'm glad to see so many
of you here today.

3
00:00:32,620 --> 00:00:42,550
I'm gonna talk to you today about
the memory profiler in Unity.

4
00:00:44,980 --> 00:00:50,220
Day-to-day I work at Unity
as a core developer.

5
00:00:50,220 --> 00:00:57,190
Before I joined Unity,
I worked at several game studios

6
00:00:57,190 --> 00:01:01,650
and released games like Limbo,
Watchmen, and Total Overdose.

7
00:01:03,150 --> 00:01:11,600
At Unity, I am primarily focused on
optimizations and performance

8
00:01:11,600 --> 00:01:22,520
and making the tools to enable you to profile your
games and get them as performant as possible.

9
00:01:22,520 --> 00:01:28,630
And I like Legos.

10
00:01:28,630 --> 00:01:34,110
So, when you're creating your games,
there's several things that you'll want to address

11
00:01:34,110 --> 00:01:37,580
when when optimizing your games.

12
00:01:37,580 --> 00:01:42,730
The obvious, of course, is frames
per second or framerate,

13
00:01:42,730 --> 00:01:50,420
which is where the user gets the smooth
experience of the game that runs 30 or 60 FPS.

14
00:01:50,420 --> 00:01:53,290
So there's two limiting factors to this.

15
00:01:53,290 --> 00:01:59,720
Namely, the time game takes to to run
a frame, and that's on the CPU side.

16
00:01:59,720 --> 00:02:08,169
So that could be game code, physics, skinning,
other heavy tasks that run on the CPU side.

17
00:02:08,169 --> 00:02:14,419
And then there's the GPU side, which is things
that run on the graphics card

18
00:02:14,419 --> 00:02:18,069
and that's drawcalls,
shaders, fill rate.

19
00:02:20,329 --> 00:02:26,889
And the game never runs faster
than the limiting factor of these two.

20
00:02:26,889 --> 00:02:31,514
So, another thing to think about

21
00:02:31,515 --> 00:02:36,339
is not to have spikes during your frame rate,
because that'll feel like, for the user,

22
00:02:36,339 --> 00:02:40,512
you'll have a jaggy experience

23
00:02:40,513 --> 00:02:46,885
because you get frames spikes
because of heavy CPU tasks

24
00:02:46,959 --> 00:02:56,169
like garbage collection, or physics
world rebuild, or scene load.

25
00:02:56,169 --> 00:03:02,889
Also, memory is an important thing
to keep in mind when developing your game

26
00:03:02,889 --> 00:03:05,699
and there two main reasons for this:

27
00:03:06,729 --> 00:03:10,949
Keeping the runtime memory low, so you
can fit in memory on the device,

28
00:03:13,899 --> 00:03:24,429
and then to to keep the memory activity low
to avoid the garbage collector to kick in.

29
00:03:26,379 --> 00:03:31,259
So in Unity Pro, we have a tool
for this. It's the Unity profiler.

30
00:03:31,259 --> 00:03:37,109
And this has several focus areas like
CPU, GPU, audio, physics, memory.

31
00:03:38,579 --> 00:03:44,879
But this time, I'll only talk about
the CPU profiler and the memory profiler.

32
00:03:44,879 --> 00:03:50,254
A new thing in Unity 4.1 is that
we have a detailed memory view

33
00:03:50,255 --> 00:03:53,229
of what is in memory
at the moment

34
00:03:53,229 --> 00:03:59,829
and coming in Unity 4.2, we also
have reference view for this

35
00:03:59,830 --> 00:04:06,429
so you can see where a
certain asset is referenced from.

36
00:04:10,499 --> 00:04:20,409
The CPU profiler. It will let you use time
consumptions for each frame for each method.

37
00:04:20,409 --> 00:04:25,770
So this is displayed in a hierarchy
view, as you can see up here,

38
00:04:26,759 --> 00:04:31,364
and it can be sorted by the
most time consuming

39
00:04:31,365 --> 00:04:35,969
or the most garbage... the most
memory heavy functions.

40
00:04:38,139 --> 00:04:42,460
The profiler also has the ability
to connect to a running player,

41
00:04:42,460 --> 00:04:44,890
so if you have your game
running in iPhone or Android,

42
00:04:44,891 --> 00:04:47,319
you can connect the profiler
and can actually see

43
00:04:47,319 --> 00:04:52,349
the profile from the game
running on the device.

44
00:04:52,349 --> 00:04:59,550
This is done by using the menu up
in the top of the active profiler menu.

45
00:04:59,550 --> 00:05:03,300
So in the editor, you also have
to turn on deep profiling.

46
00:05:04,210 --> 00:05:07,699
This will instrument all calls
in your managed code.

47
00:05:07,699 --> 00:05:10,774
So it'll give you a much more
detailed view, but it also has

48
00:05:10,775 --> 00:05:15,249
a large overhead because all
methods are instrumented now.

49
00:05:16,649 --> 00:05:28,239
But it can be used in small scenes to drill down
and find fine details on your performance.

50
00:05:29,119 --> 00:05:34,289
And so in Unity 4.1, we also have made
some improvements to the memory profiler,

51
00:05:34,289 --> 00:05:41,499
which will let you inspects the memory at
runtime at a much finer level than you used to.

52
00:05:43,489 --> 00:05:47,619
There's a simple view and
a more detailed view.

53
00:05:47,619 --> 00:05:49,840
The detailed view you can see up here.

54
00:05:49,840 --> 00:05:54,720
It's expensive to calculate so that's why
there's a button for it-- it's "take sample"

55
00:05:54,720 --> 00:06:01,899
and then you'll get a snapshot of how the memory looks
at the moment on your device or in the editor.

56
00:06:03,379 --> 00:06:10,639
So, detailed view will show you a list of all Unity
objects, like assets and scene objects

57
00:06:10,639 --> 00:06:15,099
and it will also have some calculations of
some of the core areas of Unity

58
00:06:15,099 --> 00:06:20,460
like webstreams, Mono
managed heap, shader lab,

59
00:06:20,461 --> 00:06:26,720
many more areas that
take up memory in Unity.

60
00:06:27,620 --> 00:06:35,619
This view will then let you find
more memory consuming objects.

61
00:06:35,619 --> 00:06:42,110
If you, for example, have an uncompressed
texture that slipped into production

62
00:06:42,110 --> 00:06:47,160
or an excessively large section
that should be reduced in size

63
00:06:47,160 --> 00:06:51,870
let's you pinpoint these much easier.

64
00:06:51,870 --> 00:06:56,650
And then in Unity 4.2 we've also
implemented the reference view.

65
00:06:56,650 --> 00:07:01,299
As you can see up on the screen

66
00:07:01,299 --> 00:07:05,279
where you can actually see where
a certain asset is referenced from

67
00:07:05,279 --> 00:07:08,299
what script, what game objects, and so on.

68
00:07:08,299 --> 00:07:18,249
that'll help you to to pinpoint if you have memory leaks
because you're holding references to an object.

69
00:07:21,460 --> 00:07:31,740
So, the simple memory view in the memory profiler
shows some key numbers and in the used memory.

70
00:07:31,740 --> 00:07:35,530
As you can see, it has used size
and the reserve size,

71
00:07:35,530 --> 00:07:38,300
and that's because in Unity
we reserve a block of memory

72
00:07:38,300 --> 00:07:40,720
and use that to make our locations from.

73
00:07:40,720 --> 00:07:47,919
So there's reserved and used, both for Unity native

74
00:07:47,919 --> 00:07:52,999
and for Mono, the managed memory.

75
00:07:52,999 --> 00:07:59,849
There's also a GFX driver point up there
and that gives an estimated calculation

76
00:07:59,850 --> 00:08:06,699
of what textures and meshes
are uploaded to the graphics driver.

77
00:08:06,699 --> 00:08:15,579
But it's an estimate because you can't really get
the correct or the precise numbers from the drivers.

78
00:08:19,009 --> 00:08:26,969
As you could see in the simple memory profiler, the
memory is split into managed and native memory.

79
00:08:26,969 --> 00:08:31,520
The managed memory is what Mono uses.

80
00:08:31,520 --> 00:08:41,480
It includes what you have allocated from your scripts
and wrappers for the game objects you have in your scripts.

81
00:08:42,850 --> 00:08:51,220
This memory is handled by Mono and this garbage
collect is whenever the garbage collector kicks in.

82
00:08:51,220 --> 00:09:00,540
On the Unity side, we have the native memory and
it's holding everything in the engine

83
00:09:00,540 --> 00:09:13,390
so this data includes texture data, vertex data,
mesh, audio, animation, game objects, components

84
00:09:13,390 --> 00:09:22,850
so everything that's held in native code where you
have just small wrappers for it from the managed code.

85
00:09:22,850 --> 00:09:28,840
And it also covers, of
course, engine internals

86
00:09:28,840 --> 00:09:34,820
like rendering, culling, shader lab, particles,
web streams, files, physics.

87
00:09:34,820 --> 00:09:41,120
There's a whole bunch of things that of
course goes in the Unity core.

88
00:09:41,120 --> 00:09:48,180
This memory is not garbage collected,
but handled explicitly.

89
00:09:49,460 --> 00:10:00,760
For assets you will need the "unload unused assets"
call from your scripts to free this memory.

90
00:10:02,090 --> 00:10:12,000
On the Mono side, the managed memory reserves a block of
system memory to use for allocations in Mono.

91
00:10:12,000 --> 00:10:17,810
And then this heap space is just being used

92
00:10:17,810 --> 00:10:22,930
whenever it's exhausted, whenever there's no more free space,

93
00:10:22,930 --> 00:10:28,840
Mono will run the garbage collector and
remove all memory that's no longer referenced.

94
00:10:31,140 --> 00:10:39,020
If Mono, after this garbage collection, can't find memory for
your allocation, it will have to allocate a new block

95
00:10:39,020 --> 00:10:42,990
and will expand into this block of memory.

96
00:10:43,739 --> 00:10:50,620
And this this will grow to fit the peak
memory usage of your application.

97
00:10:51,749 --> 00:10:56,950
The garbage collection can be a
time-consuming operation

98
00:10:56,950 --> 00:11:00,790
so you don't want to run this if you can avoid it.

99
00:11:03,200 --> 00:11:08,360
And another reason is that with high memory
activity, the memory is likely to get fragmented,

100
00:11:09,570 --> 00:11:16,630
and all the small, free memory fragments will
be unusable for large allocations,

101
00:11:16,630 --> 00:11:23,630
and then your your heap will grow
beyond what was actually needed.

102
00:11:24,860 --> 00:11:28,710
When Mono is giving memory
back to the system

103
00:11:28,710 --> 00:11:38,460
if such a heap block should completely be emptied, then
mono can give this back to the to the memory.

104
00:11:38,460 --> 00:11:43,660
But you can't really control this,
and it's also likely that there's

105
00:11:43,661 --> 00:11:48,860
allocations left in the heap segment, and
then Mono can't give it back to the system.

106
00:11:48,860 --> 00:11:55,860
So keeping the memory activity low
is a good thing.

107
00:11:56,350 --> 00:12:02,820
Here is a little example, just to show fragmentation.

108
00:12:02,820 --> 00:12:08,910
If you have all these small
holes in your heap block.

109
00:12:08,910 --> 00:12:13,130
Mono comes in, if you ask it for
some memory, it can fit it in there.

110
00:12:13,130 --> 00:12:17,040
Next time you ask for the same memory,

111
00:12:17,040 --> 00:12:22,680
because of all the holes, you can't really fit
it in. And even though there's enough free memory,

112
00:12:22,680 --> 00:12:26,220
there's just not enough contiguous
memory to give this allocation

113
00:12:26,220 --> 00:12:31,810
then Mono has to allocate a new heap block.

114
00:12:31,810 --> 00:12:38,810
Again, a reason to to keep the memory activity low.

115
00:12:41,340 --> 00:12:45,510
Even though scripting happens
in a managed language like C#

116
00:12:45,510 --> 00:12:49,320
there's a number of ways you can control the memory

117
00:12:49,320 --> 00:12:55,410
and reduce amount of allocations
made in your code and the memory activity.

118
00:12:55,410 --> 00:13:00,830
So if you have routines in your code
that need some temporary memory

119
00:13:03,740 --> 00:13:10,340
then it's worth considering allocating that memory
on your class instead of allocating it in the function.

120
00:13:10,340 --> 00:13:21,590
Because then you allocate it once and reuse the buffers
and you don't incur the memory activity in Mono.

121
00:13:21,590 --> 00:13:27,330
Another thing to consider is creating pools of objects.

122
00:13:27,330 --> 00:13:33,310
So if you have something that's used very
often with a short time span

123
00:13:33,310 --> 00:13:36,560
for example, bullets from machine gun or something like that,

124
00:13:36,560 --> 00:13:41,060
it's worth creating a pool of these
objects. And every time you need one,

125
00:13:41,060 --> 00:13:46,370
grab one from the pool, and whenever
you're done with it, put it back in the free list.

126
00:13:46,370 --> 00:13:52,010
This way, you don't have any memory activity and you
also save the the cost of instantiation

127
00:13:54,790 --> 00:13:59,900
of instantiating this object every time you need it.

128
00:13:59,900 --> 00:14:05,990
So a third thing to consider is using
structs instead of classes,

129
00:14:05,990 --> 00:14:11,820
because structs are allocated on the stack
while classes will be allocated on the heap.

130
00:14:11,820 --> 00:14:22,280
So if it's small data containers, then consider
if it's worth the using a struct instead.

131
00:14:23,740 --> 00:14:34,380
Don't use OnGUI, because it's very memory
heavy and has a lot of memory activity.

132
00:14:34,380 --> 00:14:39,550
It's good for prototyping for debugging purposes,

133
00:14:39,550 --> 00:14:51,070
but in your final game, use
something else to create your GUI.

134
00:14:51,070 --> 00:14:54,280
There's a small example here

135
00:14:54,280 --> 00:14:57,369
where on the left side, I just made a script.

136
00:14:57,369 --> 00:15:01,130
It's nothing special. It just has a data processing function.

137
00:15:02,200 --> 00:15:04,300
Every time this function is called

138
00:15:04,300 --> 00:15:08,720
it allocates a working buffer
and does nothing with it.

139
00:15:08,720 --> 00:15:10,320
But let's just fix it.

140
00:15:11,230 --> 00:15:16,170
It also passes in a little working
struct, which is actually a class here,

141
00:15:17,620 --> 00:15:21,290
and not much should be happening

142
00:15:21,290 --> 00:15:26,380
but what you can see up here is on the
memory, on the CPU profiler

143
00:15:26,380 --> 00:15:32,280
there's a lot of memory activity
going on in these functions.

144
00:15:32,280 --> 00:15:37,110
And they also take quite a lot of time
because of this special allocation.

145
00:15:39,210 --> 00:15:41,960
I've just changed these a little bit.

146
00:15:41,960 --> 00:15:48,670
I've put the working buffer on the class,
I've changed the work data to be a struct

147
00:15:48,670 --> 00:15:51,320
and then, you can see that's down here

148
00:15:51,320 --> 00:15:56,500
and there's no allocations.
And it takes no time, because

149
00:15:56,500 --> 00:16:02,260
there's nothing to do and since there's no
memory activities there is virtually nothing to do.

150
00:16:02,260 --> 00:16:09,230
So just keep that in mind to try to reduce your allocations,

151
00:16:09,300 --> 00:16:19,490
and use the CPU profiler to investigate and make sure of this.

152
00:16:21,020 --> 00:16:31,410
Some Unity objects that you allocate in scripts have
a large native memory footprint in Unity.

153
00:16:31,410 --> 00:16:41,980
An example of that is the WWW class which,
on the managed side, is only a small wrapper.

154
00:16:41,980 --> 00:16:45,585
But on the native side, it contains several buffers:

155
00:16:45,586 --> 00:16:49,690
a compressed file, decompression
buffers, and the uncompressed file.

156
00:16:51,659 --> 00:17:01,300
And this backing memory is not cleaned up
until the finalizers are called from Mono

157
00:17:02,160 --> 00:17:08,230
or if you call dispose on this WWW class manually.

158
00:17:08,230 --> 00:17:11,429
So if this is left to the garbage collector to finalize,

159
00:17:11,429 --> 00:17:16,709
then potentially it can take a very long
time before this memory is cleaned up

160
00:17:16,709 --> 00:17:25,480
and then you have some some memory
just lying around that should be cleaned up.

161
00:17:29,260 --> 00:17:33,200
So the way the garbage collector
works is kind of shown here.

162
00:17:33,200 --> 00:17:40,039
You have a reference to an object
and then you remove that from Mono

163
00:17:40,039 --> 00:17:47,630
by either setting the object to "null,"
or the object going out of scope.

164
00:17:47,630 --> 00:17:50,320
And after a while, the garbage collector will run

165
00:17:50,320 --> 00:17:58,520
this will either be because the heap space gets
exhausted, or if you manually call "GC.collect()."

166
00:17:58,520 --> 00:18:02,870
So when the memory is collected by the garbage collector

167
00:18:02,870 --> 00:18:10,049
this object is then put on the queue
for the finalizers to clean up.

168
00:18:10,049 --> 00:18:12,940
And this is handled on another thread

169
00:18:12,940 --> 00:18:16,630
and eventually, the finalizers will
run and call "dispose()" on the object.

170
00:18:16,630 --> 00:18:23,140
But you can't really tell when
or if the finalizers will run at all.

171
00:18:23,909 --> 00:18:28,610
So you have no control doing it like this.

172
00:18:28,610 --> 00:18:32,919
So to skip this round trip, you should
call "dispose()" directly on the object

173
00:18:32,919 --> 00:18:43,110
to free up the the memory and then the
object will not be given to the finalizers.

174
00:18:43,110 --> 00:18:46,630
So I have a small example that shows this.

175
00:18:57,350 --> 00:18:59,960
So I have the profiler,

176
00:18:59,960 --> 00:19:04,190
and I have a very small example here.

177
00:19:04,190 --> 00:19:08,972
Where I have trouble navigating...

178
00:19:09,000 --> 00:19:16,660
I connect to the running process over here.

179
00:19:20,210 --> 00:19:21,919
So we have this memory.

180
00:19:24,000 --> 00:19:29,520
So if I do a load of a webstream

181
00:19:29,520 --> 00:19:32,600
and then I just...

182
00:19:32,600 --> 00:19:35,929
Do you see this?

183
00:19:35,929 --> 00:19:41,930
If I null it, then you can see
the memory drops pretty quickly.

184
00:19:41,930 --> 00:19:44,060
But if the heap space..

185
00:19:44,060 --> 00:19:47,200
There it is.

186
00:19:47,200 --> 00:19:55,910
Now I just allocated a lot of heap space
not really used for anything, but...

187
00:19:55,910 --> 00:19:57,190
but it means that

188
00:19:57,190 --> 00:19:58,500


189
00:19:58,500 --> 00:20:00,310


190
00:20:00,310 --> 00:20:03,929
Now Mono has a lot more
memory reserved.

191
00:20:03,929 --> 00:20:05,170


192
00:20:05,170 --> 00:20:12,649
So there's a lot longer up to when
the garbage collector will run.

193
00:20:12,649 --> 00:20:14,960
So I load the stream,

194
00:20:14,960 --> 00:20:17,660
and I just remove the reference.

195
00:20:17,660 --> 00:20:22,330
The memory stays high because the
garbage collector is not running.

196
00:20:22,330 --> 00:20:28,060
So if I do that manually,
then the memory drops.

197
00:20:28,060 --> 00:20:32,720
So of course, when you load,

198
00:20:32,720 --> 00:20:35,169
then if you dispose your object instead,

199
00:20:35,169 --> 00:20:42,169
then the memory goes down immediately.
That's just something to remember.

200
00:20:42,180 --> 00:20:49,180
I will just move this away...

201
00:20:51,330 --> 00:20:57,049
So for asset bundles, when using asset
bundles, it's important that you know

202
00:20:57,049 --> 00:20:59,280
what memory is used by Unity

203
00:20:59,280 --> 00:21:04,110
and what was allocated in the various stages.

204
00:21:04,110 --> 00:21:07,789
So that the webstream, the WWW class

205
00:21:07,789 --> 00:21:15,250
the web stream data here holds several buffers,
depending on the settings of the stream of course.

206
00:21:15,250 --> 00:21:23,840
But if it's a compressed stream, then
it will have the compressed file,

207
00:21:23,840 --> 00:21:27,250
it'll have the decompression
buffers used by LZMA,

208
00:21:27,250 --> 00:21:32,570
and then it tests the final uncompressed data.

209
00:21:32,570 --> 00:21:37,010
The asset bundle is then created
from this web stream or WWW object,

210
00:21:37,010 --> 00:21:47,960
and allocates a map of objects that is
in the asset bundle and offsets into the file.

211
00:21:47,960 --> 00:21:48,919


212
00:21:48,919 --> 00:21:59,600
And then when loading the objects from the asset bundle, these
objects will be created in memory from the decompressed data.

213
00:22:00,230 --> 00:22:04,299
So when you have your "assetbundle_url" file,

214
00:22:04,299 --> 00:22:11,350
what you do this you can load this file
asynchronously by calling the new WWW

215
00:22:11,350 --> 00:22:14,980
and this will load the compressed file into memory.

216
00:22:14,980 --> 00:22:16,870
It will start the decompression,

217
00:22:16,870 --> 00:22:23,200
and the decompression algorithm
will allocate some buffers.

218
00:22:23,200 --> 00:22:30,430
And in Unity 4.1 and before,

219
00:22:30,430 --> 00:22:35,090
this required a buffer of 8 megabytes decompress,

220
00:22:35,090 --> 00:22:38,210
and that's just because of the settings
of the decompression.

221
00:22:38,210 --> 00:22:40,130


222
00:22:40,130 --> 00:22:47,730
This will then unpack the data and
allocate buffers for the decompressed data.

223
00:22:47,730 --> 00:22:49,270


224
00:22:49,270 --> 00:22:57,720
To avoid this 8 megabyte decompression
buffer reallocated for every file,

225
00:22:57,720 --> 00:23:03,429
in the backend of Unity we keep one 8 megabyte
buffer around for the next decompressions.

226
00:23:03,429 --> 00:23:05,270


227
00:23:05,270 --> 00:23:07,360


228
00:23:07,360 --> 00:23:14,120
So keep in mind that several parallel loads will
then each allocate such a decompression buffer

229
00:23:14,120 --> 00:23:15,450


230
00:23:15,450 --> 00:23:19,139
and this will result in a large memory spike.

231
00:23:19,139 --> 00:23:27,740
To avoid this, try to load your webstreams one at a
time, because then you can reuse this 8 megabyte buffer

232
00:23:27,740 --> 00:23:32,309
and you won't get this peak.

233
00:23:32,309 --> 00:23:47,130
And so for Unity 4.2 and beyond, we have changed
this compression, so it'll use much smaller buffers.

234
00:23:47,850 --> 00:23:54,110
So after the file is loaded, you construct the asset
bundle from the file calling the "www.assetBundle."

235
00:23:54,110 --> 00:23:59,450
This will load the map of objects
and the offsets into the webstream,

236
00:23:59,450 --> 00:24:04,000
and the asset bundle will then
retain a pointer to the webstream.

237
00:24:04,000 --> 00:24:09,580
Because if you load something from the asset
bundle, it needs the webstream to be around.

238
00:24:09,580 --> 00:24:13,470
So even if "dispose()" is called under WWW object,

239
00:24:13,470 --> 00:24:23,600
it will still be around until the
asset bundle is unloaded.

240
00:24:23,600 --> 00:24:26,580
So when objects are loaded
from the asset bundle,

241
00:24:26,580 --> 00:24:31,360
then the data from the webstream is used
to construct the requested objects.

242
00:24:31,360 --> 00:24:42,530
Then the asset bundle has a little
list of what objects it has constructed.

243
00:24:42,530 --> 00:24:46,450
So to load objects from the asset bundle

244
00:24:46,450 --> 00:24:53,260
you can use either "load," "load all," or the
"dot main assets" methods from the asset bundle.

245
00:24:53,260 --> 00:24:58,010
In the example I'll show later,
I'll just load a texture,

246
00:24:58,010 --> 00:25:03,799
and this texture will be instantiated
from the asset bundle.

247
00:25:03,799 --> 00:25:15,799
And when the texture is uploaded to the GPU,
on players, it will then be deallocated from the main memory.

248
00:25:15,799 --> 00:25:20,870
On editors, we keep this data around,

249
00:25:20,870 --> 00:25:25,630
because of the possibility of you
changing some flags in the editor.

250
00:25:26,730 --> 00:25:28,710


251
00:25:28,710 --> 00:25:32,830
And also, on platforms that use
the multi-threaded renderer...

252
00:25:32,830 --> 00:25:34,029


253
00:25:34,029 --> 00:25:37,919
The textures transfer to the render
thread and then there's a transfer buffer

254
00:25:37,919 --> 00:25:43,370
between these two threads and
that'll grow to fit the entire texture.

255
00:25:43,370 --> 00:25:53,990
Of course, this is not real-world example, because I
hope none of you have 32 megabyte textures in your games.

256
00:25:55,380 --> 00:25:58,340
So when all the objects you have
have been uploaded to the file,

257
00:25:58,340 --> 00:26:00,890
you can get rid of the webstream
data and the asset bundle.

258
00:26:00,890 --> 00:26:03,299


259
00:26:03,299 --> 00:26:10,490
So the WWW objects should
be deleted by calling "dispose()"

260
00:26:10,490 --> 00:26:14,570
and not left for the for
the garbage collector.

261
00:26:14,570 --> 00:26:15,760


262
00:26:15,760 --> 00:26:19,480
And so, as long as the
asset bundle is still around

263
00:26:19,480 --> 00:26:22,510
the webstream will not be unloaded.

264
00:26:22,510 --> 00:26:26,095
So you need to delete the asset bundle as well.

265
00:26:26,196 --> 00:26:32,510
And this can be done by calling
"unload" either false or true.

266
00:26:32,510 --> 00:26:40,090
If you call it with false, the map and the
reference to the webstream are unloaded,

267
00:26:40,090 --> 00:26:44,760
and the backing memory will be be deleted.

268
00:26:44,760 --> 00:26:47,820
If you instead call it with "unload(true),"

269
00:26:47,820 --> 00:26:51,760
then the asset bundle also uses
a list of instantiated objects,

270
00:26:51,760 --> 00:26:58,810
and deletes these objects as well.

271
00:26:58,810 --> 00:27:00,080


272
00:27:00,080 --> 00:27:05,030
So bear in mind that if you "unload(true)," then if
you have references in your scripts to objects

273
00:27:05,030 --> 00:27:06,880
created from the asset bundle,

274
00:27:06,880 --> 00:27:16,770
these will be nulled and you'll get null point
exceptions if you start accessing anyway.

275
00:27:16,770 --> 00:27:21,660
So when you're done using your assets you can
unload them by still having the asset bundle,

276
00:27:21,660 --> 00:27:26,460
and then still having a reference to the
asset bundle and then calling "unload(true)."

277
00:27:26,460 --> 00:27:32,549
You can also not have the asset bundle around
and then call "UnloadUnusedAssets()"

278
00:27:32,549 --> 00:27:41,299
when all references to to your
instantiated objects are gone.

279
00:27:41,299 --> 00:27:42,750


280
00:27:42,750 --> 00:27:48,080
So if an object is not--or an asset is not--
unloaded when you call "UnloadUnusedAssets(),"

281
00:27:48,080 --> 00:27:51,280
it's because it's still being
referenced somewhere in the code.

282
00:27:51,280 --> 00:28:00,590
In the profiler in Unity 4.1, you'll be able to
see if the object is referenced from script,

283
00:28:00,590 --> 00:28:04,039
or if it still has references,

284
00:28:04,039 --> 00:28:06,220


285
00:28:06,220 --> 00:28:11,030
or if it's marked as hide and don't save.

286
00:28:11,030 --> 00:28:16,950
So in Unity 4.2, we've added additional
functionality so you can actually see

287
00:28:16,950 --> 00:28:24,259
if it's referenced, what script it's referencing, the
object, or what material is referencing the texture.

288
00:28:24,259 --> 00:28:35,690
So it will help you pinpoint where
your references are being held.

289
00:28:36,680 --> 00:28:42,020
So for the most efficient way of
loading an asset bundle

290
00:28:42,020 --> 00:28:48,300
memory-wise, it is, if possible, to just
load one asset bundle at a time.

291
00:28:48,300 --> 00:28:54,480
Load what's needed from the asset bundle, and then
destroy the webstream and the asset bundle again.

292
00:28:54,480 --> 00:28:57,070
So here's a small example:

293
00:28:57,070 --> 00:29:03,450
Load a texture from from the asset bundle, and
whenever this code routine is done running,

294
00:29:03,450 --> 00:29:08,700
all memory from the webstream and
the asset bundle is unloaded and destroyed

295
00:29:08,700 --> 00:29:12,090
and there's only the texture memory left.

296
00:29:12,090 --> 00:29:22,940
So to later get rid of this texture, remove the
reference and call "UnloadUnsuedAssets()."

297
00:29:24,920 --> 00:29:28,760
So I have yet another small example.

298
00:29:28,760 --> 00:29:35,210


299
00:29:35,210 --> 00:29:38,770
Well, it's the same example.

300
00:29:38,770 --> 00:29:45,770


301
00:29:48,480 --> 00:29:52,560


302
00:29:52,560 --> 00:29:58,000
There is the the web stream.

303
00:29:58,000 --> 00:30:03,740
If I load that, notice that the memory...

304
00:30:03,740 --> 00:30:10,740


305
00:30:11,230 --> 00:30:13,660
That the memory grew.

306
00:30:13,660 --> 00:30:18,570
What we'll do is just go to
detailed view and take a sample.

307
00:30:18,570 --> 00:30:25,389
Here, we can then see that in "others,"
we now have a webstream loaded

308
00:30:25,389 --> 00:30:31,539
and we have the name name of that
stream, and it's taking up 32 megabytes.

309
00:30:31,539 --> 00:30:40,320
Most of this is in 4.2, so you'll have to wait a
little bit to get the the latest features of this.

310
00:30:40,320 --> 00:30:43,180


311
00:30:43,180 --> 00:30:50,260
If we load the asset bundle, we
can dispose of the webstream.

312
00:30:50,260 --> 00:30:51,920


313
00:30:51,920 --> 00:30:54,290
But you could see that the
memory still didn't go down.

314
00:30:54,290 --> 00:31:02,880
That's because we still have the webstream
around, because it's referenced by the asset bundle.

315
00:31:02,880 --> 00:31:10,510
So we load a texture.

316
00:31:10,510 --> 00:31:17,309
We now see that the asset has
grown and now has the texture there.

317
00:31:17,309 --> 00:31:20,250
We can also see that it's referenced once,

318
00:31:20,250 --> 00:31:25,260
and is referenced by the script, because
I'm just holding a reference to it.

319
00:31:27,560 --> 00:31:31,020
We can "unload(false)."

320
00:31:31,020 --> 00:31:36,680
So now the webstream, the
backing data, is gone.

321
00:31:36,680 --> 00:31:38,220
Of course, take a sample.

322
00:31:38,220 --> 00:31:41,050
See that the web stream is
gone from the from the list

323
00:31:41,050 --> 00:31:43,000


324
00:31:43,000 --> 00:31:49,110
Also the transfer buffer I was talking
about from the graphics GPU

325
00:31:49,110 --> 00:31:53,419
is this 32 megabytes that I've allocated here.

326
00:31:53,419 --> 00:32:00,610
This is not going to be relevant
for a real game project,

327
00:32:00,610 --> 00:32:05,750
but it's just to show that it's
there and it's being registered.

328
00:32:05,750 --> 00:32:10,610
So if we then remove the texture reference,

329
00:32:10,610 --> 00:32:14,130
see, the memory didn't really go down.

330
00:32:14,130 --> 00:32:18,159
We take a sample and we can
see that the asset is still around,

331
00:32:18,159 --> 00:32:21,559
but now, there's no more references.

332
00:32:21,559 --> 00:32:23,304
So that means that is you
call "UnloadUnusedAssets(),"

333
00:32:23,305 --> 00:32:28,179
the memory will go down,
and the texture is gone.

334
00:32:28,179 --> 00:32:30,970
So this is just to show you

335
00:32:30,970 --> 00:32:37,710
how you can investigate your memory
usage using the memory profiler.

336
00:32:37,710 --> 00:32:46,350
So in assets, the texture is gone
and everything is back to normal.

337
00:32:46,350 --> 00:32:53,350
Yes, that's it here.

338
00:32:58,289 --> 00:32:59,990
So, conclusions about this.

339
00:32:59,990 --> 00:33:01,610


340
00:33:01,610 --> 00:33:09,210
Avoid memory activity to keep your
Mono memory unfragmented,

341
00:33:09,210 --> 00:33:16,440
and to avoid the garbage collector kicking
in and causing frame spikes in your game.

342
00:33:16,440 --> 00:33:18,010


343
00:33:18,010 --> 00:33:23,400
Use the memory profiler to monitor memory usage.

344
00:33:23,400 --> 00:33:33,200
Or actually, both use the CPU and the memory profiler
to monitor memory activity in the CPU profiler,

345
00:33:33,200 --> 00:33:42,000
and see what objects you have
allocated using the memory profiler.

346
00:33:42,000 --> 00:33:50,760
To keep the memory peaks down, try to
load just one WWW object at a time.

347
00:33:50,760 --> 00:33:52,000


348
00:33:52,000 --> 00:33:57,649
Use "dispose()" on these objects
that derive from IDisposable.

349
00:33:57,649 --> 00:34:00,690
WWW is an example of that.

350
00:34:00,690 --> 00:34:06,710
Because they have a large memory footprint
on the native side, so you you want

351
00:34:06,710 --> 00:34:11,099
to get rid of them as soon as
possible and control that yourself.

352
00:34:11,109 --> 00:34:19,139
And then of course, use "UnloadUnusedAssets()"
to clean up the assets from memory.

353
00:34:21,029 --> 00:34:24,029
So, that's it.

354
00:34:32,639 --> 00:34:36,550
So, any questions?

355
00:34:41,919 --> 00:34:45,599
(Thank you very much for your talk.
I have a couple of questions.)

356
00:34:45,599 --> 00:34:49,979
(Well, just a question about
the new memory profiler.)

357
00:34:49,979 --> 00:34:59,839
(Will it be possible to automatically give detail as upshots?
Right now, I think you have to press manually,)

358
00:34:59,839 --> 00:35:03,959
(but I would like to have like, I don't know,
every ten seconds or something like this.)

359
00:35:03,959 --> 00:35:08,020
Yeah, I'm thinking about making the option
where you can actually do it every frame.

360
00:35:08,020 --> 00:35:11,739
Even though you'll take the
perfomance hit from it,

361
00:35:11,739 --> 00:35:17,460
you'll actually be able to see
what goes on every frame.

362
00:35:17,460 --> 00:35:22,629
Or maybe, as you say, doing it with a
time interval. That makes a lot of sense.

363
00:35:22,629 --> 00:35:30,259
Another thing we want to do is to make a tool
where you can make a div between two snapshots.

364
00:35:30,259 --> 00:35:36,259
- (This will be in the next release or 4.3?)
- Well, the detailed will.

365
00:35:36,259 --> 00:35:47,419
But, every frame, or with intervals and the div, that will be in
yet another future release, but yeah i'm working on it, so...

366
00:35:47,419 --> 00:35:54,689
(Another one, about the reference view in
Unity 4.2, I guess it's only for Unity objects?)

367
00:35:54,689 --> 00:35:55,929


368
00:35:55,929 --> 00:36:02,239
It's for for assets, but...

369
00:36:02,239 --> 00:36:04,049


370
00:36:04,049 --> 00:36:09,119
It's for Unity objects, but some assets.

371
00:36:09,119 --> 00:36:16,119
A material, for example, that can
reference a texture...

372
00:36:16,269 --> 00:36:25,409
But yeah, it's only for Unity objects in terms of
assets and game objects and stuff like that.

373
00:36:25,409 --> 00:36:30,459
(Say for instance I create my
own native object or whatever it is.)

374
00:36:30,459 --> 00:36:41,139
(Is there a way I can tell the profiler like, "send the
reference" or something like this, so it can count this too?)

375
00:36:41,139 --> 00:36:46,199
No, not at the moment, but
it's definitely good in the end.

376
00:36:46,199 --> 00:36:50,449
Just send that feature request to
us and we'll look into if it's possible.

377
00:36:50,449 --> 00:36:57,129
Because of course, we want to empower you to
be able to get as detailed a view as possible.

378
00:36:57,129 --> 00:37:00,720
(Okay. Thank you very much.
Very interesting.)

379
00:37:10,449 --> 00:37:13,669


380
00:37:13,669 --> 00:37:19,269


381
00:37:19,269 --> 00:37:20,770


382
00:37:20,770 --> 00:37:27,770


383
00:37:32,299 --> 00:37:39,530
Yes, a lot of it can be done in the editor,

384
00:37:39,530 --> 00:37:46,470
because if you have objects that are not unloaded
because you still have references to them

385
00:37:46,470 --> 00:37:52,709
and so on, that's good to use the memory
profiler to find those and clean it out.

386
00:37:52,709 --> 00:38:00,269
But, if you want to get a precise measure for what
your textures and assets are using on the device,

387
00:38:00,269 --> 00:38:05,299
you should to run the the game on
the device and connect to the profiler.

388
00:38:05,299 --> 00:38:16,029
Because the numbers you get in the view will then be
calculated on the device and will be very precise.

389
00:38:16,029 --> 00:38:25,399
In some cases, a little bit estimated, but usually it's the
precise footprint of what those assets are taking on the device.

390
00:38:25,399 --> 00:38:29,459
And we don't we don't emulate in the editor
out how much it's going to take on the device

391
00:38:29,459 --> 00:38:36,729
because that's that's always going to
be off, and so we don't want to do that.

392
00:38:36,729 --> 00:38:43,729


393
00:38:52,289 --> 00:38:56,690


394
00:38:56,690 --> 00:38:59,069


395
00:38:59,069 --> 00:39:03,869


396
00:39:03,869 --> 00:39:08,989


397
00:39:08,989 --> 00:39:11,599


398
00:39:11,599 --> 00:39:15,299


399
00:39:15,299 --> 00:39:18,270


400
00:39:18,270 --> 00:39:20,130


401
00:39:20,130 --> 00:39:21,610


402
00:39:21,610 --> 00:39:28,610


403
00:39:30,269 --> 00:39:38,030
Yes, if you do an object pool
of, for example, bullets.

404
00:39:38,030 --> 00:39:43,559
Then you instantiate all those objects into
your pool, so you only call "instantiate"

405
00:39:43,559 --> 00:39:48,759
a fixed number of times. Then you grab
the objects without instantiating them

406
00:39:48,759 --> 00:39:50,819
but just grab them in and out of the pool.

407
00:39:50,819 --> 00:39:53,919
And then, of course the memory
on the Unity side will also

408
00:39:53,919 --> 00:39:58,919
not fragment, because it will just
stay in memory. And you just

409
00:39:58,920 --> 00:40:05,619
pull the object in and out of your
scene, but it's always in memory.

410
00:40:07,319 --> 00:40:08,539


411
00:40:08,539 --> 00:40:17,029
Object pools, you also save the instantiation
if you just instantiate your objects.

412
00:40:17,959 --> 00:40:24,729
And there's, I think, the astrodude
project on the Unity asset store

413
00:40:24,729 --> 00:40:35,149
uses object pools a lot, so you can see a
lot of stuff best practices in that project.

414
00:40:37,429 --> 00:40:44,429


415
00:40:48,599 --> 00:40:51,939


416
00:40:51,939 --> 00:40:55,409


417
00:40:55,409 --> 00:40:58,789


418
00:40:58,789 --> 00:41:05,029


419
00:41:05,029 --> 00:41:08,199


420
00:41:08,199 --> 00:41:12,799


421
00:41:12,799 --> 00:41:13,739


422
00:41:13,739 --> 00:41:15,819


423
00:41:15,819 --> 00:41:19,249


424
00:41:19,249 --> 00:41:20,899


425
00:41:20,899 --> 00:41:24,399


426
00:41:24,399 --> 00:41:28,009


427
00:41:28,009 --> 00:41:31,630


428
00:41:31,630 --> 00:41:33,479


429
00:41:33,479 --> 00:41:40,479


430
00:41:43,049 --> 00:41:45,619
Yes

431
00:41:45,619 --> 00:41:47,309


432
00:41:47,309 --> 00:41:52,319
I heard this also when we were in Korea,
that some guys on an Android project

433
00:41:52,319 --> 00:41:57,939
also had some big memory
footprints from their scripts.

434
00:41:57,939 --> 00:42:00,109


435
00:42:00,109 --> 00:42:01,470


436
00:42:01,470 --> 00:42:06,150
I was a little puzzled about that because
it shouldn't shouldn't be that bad.

437
00:42:06,150 --> 00:42:13,329
But of course it's always a good thing to not include
things in your project that you're not using.

438
00:42:13,329 --> 00:42:21,879
But, it seems like there's something, a bug, somewhere
about these scripts because we've seen it before

439
00:42:21,879 --> 00:42:26,029
and you also seem to have it.

440
00:42:26,029 --> 00:42:32,779
And please report these
bugs because it seems wrong.

441
00:42:32,779 --> 00:42:36,369


442
00:42:36,369 --> 00:42:40,630
I can't really tell you why, because
20 megabytes for a couple of scripts

443
00:42:40,630 --> 00:42:46,079
doesn't make sense anywhere, so we would
really like to investigate that and find out why.

444
00:42:46,079 --> 00:42:47,029


445
00:42:47,029 --> 00:42:53,359
And that being said, the the memory profiler, even
though it displays a lot of the memory that's going on,

446
00:42:53,359 --> 00:42:56,489
we're not catching everything.

447
00:42:56,489 --> 00:43:07,589
So if you see big differences between what is
actually reported on the device and what we report,

448
00:43:07,589 --> 00:43:13,799
then tell us, because then there's something we're not
catching and we want to get this as precise as possible.

449
00:43:13,799 --> 00:43:18,809
But it's a work in progress, and we're trying to
get it better and better every time.

450
00:43:18,809 --> 00:43:26,019
But just tell us and we'll
make sure we get it better.

451
00:43:26,019 --> 00:43:26,910


452
00:43:26,910 --> 00:43:31,580


453
00:43:31,580 --> 00:43:34,709


454
00:43:34,709 --> 00:43:37,509


455
00:43:37,509 --> 00:43:41,839


456
00:43:41,839 --> 00:43:45,329


457
00:43:45,329 --> 00:43:46,140


458
00:43:46,140 --> 00:43:48,379


459
00:43:48,379 --> 00:43:52,369


460
00:43:52,369 --> 00:43:53,789


461
00:43:53,789 --> 00:43:56,059


462
00:43:56,059 --> 00:43:59,440


463
00:43:59,440 --> 00:44:00,589


464
00:44:00,589 --> 00:44:01,949


465
00:44:01,949 --> 00:44:02,800


466
00:44:02,800 --> 00:44:09,800


467
00:44:19,939 --> 00:44:21,369
Yes

468
00:44:21,369 --> 00:44:22,609


469
00:44:22,609 --> 00:44:25,800
You should avoid using it totally.

470
00:44:25,800 --> 00:44:31,410
Because as soon as there is
an OnGUI function on a class,

471
00:44:31,410 --> 00:44:37,479
even though it's empty, it will start
calling the GUI layout managers.

472
00:44:37,479 --> 00:44:43,819
and setting up a lot of stuff, and it calls your OnGUI,
and then it's just empty, and then just returns

473
00:44:43,819 --> 00:44:48,299
but it has already done all this
setup, and it does that every frame.

474
00:44:52,009 --> 00:45:01,649
So, if you need OnGUI in your editor
for debugging purposes, for any reason

475
00:45:01,649 --> 00:45:06,660
then use preprocessors to get
rid of the entire OnGUI function

476
00:45:06,660 --> 00:45:16,589
on when you compile for
your target platforms.

477
00:45:16,649 --> 00:45:23,649


478
00:45:30,249 --> 00:45:37,529
Ah yes, it's time, but if you have
more questions, feel free to come by.

479
00:45:37,529 --> 00:45:43,379
I'll be out here afterwards, so you can
just come come over and ask questions.

480
00:45:43,379 --> 00:45:50,379
Thank you for listening.